<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.29">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-11-18">
<meta name="description" content="Agent for Psychologists">

<title>PsyLens – Rahul Menon</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-bcbce66894bfa8e7e94e40e0186b9bb8.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-40bf1082f6f368eca58c43e1c62bfe70.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Rahul Menon</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../pages/about.html"> 
<span class="menu-text">About Me</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/rahulmenon1758/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/dataexplorerRahul"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#resources" id="toc-resources" class="nav-link active" data-scroll-target="#resources">Resources</a></li>
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a></li>
  <li><a href="#agent" id="toc-agent" class="nav-link" data-scroll-target="#agent">Agent</a>
  <ul class="collapse">
  <li><a href="#sec-db_tool" id="toc-sec-db_tool" class="nav-link" data-scroll-target="#sec-db_tool">Database Tool</a></li>
  <li><a href="#sec-rag_tool" id="toc-sec-rag_tool" class="nav-link" data-scroll-target="#sec-rag_tool">RAG Tool</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">PsyLens</h1>
  <div class="quarto-categories">
    <div class="quarto-category">GenAI</div>
  </div>
  </div>

<div>
  <div class="description">
    Agent for Psychologists
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 18, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<p>You can find the code in this <a href="https://github.com/dataexplorerRahul/Agentic_RAG">repo</a>.</p>
</section>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>This project is part of my work at TerrablueXT and the objective is to enable Psychologists query/interact with their client’s CRF (Case-Report-Form) response &amp; Mental-health report (PDF).</p>
<p>All the details about various approaches &amp; steps to execute the project are explain in the following sections.</p>
</section>
<section id="agent" class="level2">
<h2 class="anchored" data-anchor-id="agent">Agent</h2>
<p><img src="../images/psylens/agent_workflow.png" class="img-fluid"> The above image demonstrates the Agent workflow that was implemented for this usecase. It is a mixture of both Routing worflow &amp; Agent (LangChain’s <a href="https://docs.langchain.com/oss/python/langgraph/workflows-agents">blog</a>) The purpose of each node is as follows:</p>
<ul>
<li><p>Input guardrail: This node provides protection through OpenAI’s <a href="https://openai.github.io/openai-guardrails-python/">guardrails</a> at following levels:</p>
<ul>
<li>Moderation: Detect harmful or policy-violating content including hate speech, harassment, self-harm, and other inappropriate content.</li>
<li>Jailbreak: Detect jailbreak attempts by identifying various attack patterns.</li>
<li>Off-topic prompts: Detect prompts deviating for the core task of the agent.</li>
</ul></li>
<li><p>unrelated_query_handler: Any user-query that trips the Guardrails it routed to this node, which returns a regret message.</p></li>
<li><p>intent_classifier: This node detects the intent of the input query and routes it accordingly to either the greetings or planner nodes.</p></li>
<li><p>greetings: This node handles the greeting related users messages and returns an appropriate response.</p></li>
<li><p>planner: This is the main agent responsibel to generate/answer the user’s actual query from the database or PDF reports. It has access to 2 tools: Database-tool &amp; RAG-tool, using which it enriches the LLM context with relevant information to answer user’s query.</p></li>
<li><p>conversation_summary: This node generates a concise summary of the running multi-turn conversation between the user &amp; agent. It is triggered when accumulated number of messages exceeds 6 (3-turns).</p></li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that the user here is the Psychologist</p>
</div>
</div>
<section id="sec-db_tool" class="level3">
<h3 class="anchored" data-anchor-id="sec-db_tool">Database Tool</h3>
<p><img src="../images/psylens/db_tool_pipeline.png" class="img-fluid"> To answer user’s query related to data stored in database i.e.&nbsp;Client’s demographic, health-history, responses to GAD &amp; PHQ questionnaires. To achieve this, I took the following approach:</p>
<ul>
<li>SQL query generation: Firstly, user’s natural language query is converted to an SQL query, using an LLM API call enriched with the database schema.</li>
<li>Query execution: The generated SQL query is then executed using LangChain’s <code>SQLDatabase</code> engine and the fetched results are returned to the Planner agent.</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>As an security measure, I created a user profile with read-only privileges of the database, to run/execute the generated SQL query. This is to prevent executing a malicious query, modifying the database in unwanted ways.</p>
</div>
</div>
</section>
<section id="sec-rag_tool" class="level3">
<h3 class="anchored" data-anchor-id="sec-rag_tool">RAG Tool</h3>
<p>Retrieval Augmented Generation is used to augement &amp; enrich the context of LLM to answer queries from domain-specific or personal knowledge base which the LLM hasn’t been trained on. This is a technique to ground the LLM with unseen &amp; specific data and generate responses based on that.</p>
<p>Here, in this case the knowledge base consists of Psychologist PDF reports, each of which contain the mental-health analysis for a particular client. I am leveraging RAG to let Psychologist interact with these report to reduce the analysis effort during/before 1-on-1 meeting with the client.</p>
<p>The PDF reports are quite structured in their format:</p>
<ul>
<li>Multimodal i.e.&nbsp;Text + Plots/Graphs(images) + Tabular data</li>
<li>All the topic headings in each report are the same except the content</li>
</ul>
<p>Since, the reports are multimodal (as they contain text &amp; images), there are following approaches mentioned in this <a href="https://developer.nvidia.com/blog/an-easy-introduction-to-multimodal-retrieval-augmented-generation/">blog</a>:</p>
<ul>
<li>Embed all modalities into the same vector space</li>
<li>Ground all modalities into one primary modality</li>
<li>Have separate stores for different modalities</li>
</ul>
<p>I chose the 2nd approach, where I ground all the modalities into the text modality.</p>
<section id="pipeline" class="level4">
<h4 class="anchored" data-anchor-id="pipeline">Pipeline</h4>
<p><img src="../images/psylens/rag_pipeline.png" class="img-fluid"> The RAG pipeline I used has the following steps:</p>
<section id="document-parsing" class="level5">
<h5 class="anchored" data-anchor-id="document-parsing">Document Parsing</h5>
<p>This steps involves loading &amp; the parsing the content in the PDF. For this step, Docling package was used to</p>
<ul>
<li>Extract text content as markdown</li>
<li>Extract table as markdown (preserves the tabular structure to some extent in text format) because ~90% of PDF is just tables.</li>
<li>Extract plots-images as base64 encoded strings.</li>
</ul>
<p>I did try other PDF loaders from LangChain such as PyMuPDF, PDFPlumber &amp; PyMuPDF4LLM, but each of them had issues of their own like unable to extract tables as markdown text, adding extra columns in tables etc.</p>
<p>Docling provide good results in the above tasks and that’s the reason for this choice.</p>
</section>
<section id="document-chunking" class="level5">
<h5 class="anchored" data-anchor-id="document-chunking">Document Chunking</h5>
<p>This is the most crucial step in a RAG pipeline. As the name suggests, we divide the entire document into chunks which are then embedded into a vector store. There are many different chunking strategies to choose from, but keeping document-structure &amp; context preservation between chunks in mind, I chose <strong>Document-structure based chunking</strong>.</p>
<p>What this steps involves is to chunk the entire document based on the Headers (specifically Heading 2) using <code>MarkdownTextHeaderSplitter</code> from LangChain. The effect: Preserves context of each title in document by keeping all the content of that title together in a single chunk.</p>
<p>Extra preprocessing:</p>
<ul>
<li>Removing Page header from the markdown text extracted during parsing step</li>
<li>Adding metadata such as file-name, chunk-type(image or text)</li>
</ul>
</section>
<section id="contextual-summary" class="level5">
<h5 class="anchored" data-anchor-id="contextual-summary">Contextual Summary</h5>
<p>This is an additional step in RAG pipeline suggested in Anthropic’s <a href="https://www.anthropic.com/engineering/contextual-retrieval">blog</a>, which results in better retrieval metrics. It involves generating a summary of a particular chunk w.r.t to the entire document. This summary helps locate the chunk in the document and provide necessary context about what the chunk content is about w.r.t the document. The summary is then prepended to original chunk and then embedded into the vector store</p>
<p>Since, the plot-images need to converted to text itself, I didn’t generate a contextual summary for them.</p>
</section>
<section id="indexing" class="level5">
<h5 class="anchored" data-anchor-id="indexing">Indexing</h5>
<p>Now, to index the chunks, I experimented along these aspects:</p>
<ul>
<li><p>Choice of Embedding model: MTEB <a href="https://huggingface.co/spaces/mteb/leaderboard">leaderboard</a> is a good reference to compare Embedding models’ performance for different tasks. In our case, since retrieval is the main task, I tried out the following Embedding models:</p>
<ul>
<li><a href="https://huggingface.co/Qwen/Qwen3-Embedding-8B">qwen3-embedding-8B</a>: Its open-source and is the top-performer on the leaderboard currently. Accessed this model via Nebius’s API, due to resource constraints.</li>
<li><a href="https://huggingface.co/Qwen/Qwen3-Embedding-4B">qwen3-embedding-4B</a>: Its open-source and provides great balance between performance &amp; memory requirement.</li>
<li><a href="https://ai.google.dev/gemini-api/docs/embeddings">gemini-embedding-001</a>: Accessible via API and was the top-model before Qwen3 dethroned it.</li>
<li><a href="https://blog.voyageai.com/2024/09/18/voyage-3/">voyage-3-large</a>: Suggested in Anthropic’s <a href="https://www.anthropic.com/engineering/contextual-retrieval">blog</a>. This model can be accessed via API and they offer first 200M embedding tokens for free</li>
<li><a href="https://huggingface.co/intfloat/multilingual-e5-large-instruct">multilingual-e5-large-instruct</a>: Due to smaller size and it has decent performance on retrieval task</li>
</ul></li>
<li><p>Choice of Vector-store: As the name suggests, they are used to store the embedding vectors of all the chunks. I chose Qdrant due to the following reasons:</p>
<ul>
<li><p>Open-source &amp; can be run locally</p></li>
<li><p>Written in Rust which makes it fast &amp; reliable</p></li>
<li><p>Fastest metadata filtering</p></li>
<li><p>High throughput</p>
<p>To create the retriever, I used LangChain’s <code>MultiVectorRetriever</code>, with <code>QdrantVectorStore</code> as vector-store to index the chunk-embedding-vectors &amp; <code>InMemoryStore</code> as doc-store to store the original document chunks</p></li>
</ul></li>
<li><p>Choice of Search-type: I experimented with the following search-types:</p>
<ul>
<li><strong>Semantic search</strong>: It involves retrieving documents based on similarity scores between the query-embedding &amp; vector-embeddings in the vector-store</li>
<li><strong>Hybrid search</strong>: It combines Semantic search with Keyword-based (BM25) search, retrieving documents using RRF(Reciprocal Rank Fusion) as combination &amp; ranking strategy.</li>
</ul></li>
</ul>
</section>
<section id="evaluation" class="level5">
<h5 class="anchored" data-anchor-id="evaluation">Evaluation</h5>
<p>To log the performance of the retrieval, I created a evaluation set consisting of queries &amp; golden-chunk-ids(ground-truth) key-value pairs against which the pipeline will be evaluated. The metric I chose in this case was <code>Recall@k</code>, where k={3, 5, 7}.</p>
<p>Following are the results for the experiments conducted:</p>
<table class="table-striped table-hover table-bordered table">
<caption>Embedding-model &amp; Search-type choice Performance</caption>
<colgroup>
<col style="width: 30%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Embedding model</th>
<th style="text-align: center;">Semantic Search</th>
<th style="text-align: center;">Hybrid Search</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">multilingual-e5-large-instruct</td>
<td style="text-align: center;">Recall@3: 81.67% &nbsp;Recall@5: 90% &nbsp;Recall@7: 96%</td>
<td style="text-align: center;">Recall@3: 82.33% &nbsp;Recall@5: 95% &nbsp;Recall@7: 97%</td>
</tr>
<tr class="even">
<td style="text-align: center;">gemini-embedding-001</td>
<td style="text-align: center;">Recall@3: 77.33% &nbsp;Recall@5: 88.67% &nbsp;Recall@7: 95.33%</td>
<td style="text-align: center;">Recall@3: 84% &nbsp;Recall@5: 93% &nbsp;Recall@7: 97.67%</td>
</tr>
<tr class="odd">
<td style="text-align: center;">qwen3-embedding-4B</td>
<td style="text-align: center;">Recall@3: 79% &nbsp;Recall@5: 88% &nbsp;Recall@7: 94.67%</td>
<td style="text-align: center;">Recall@3: 83.33% &nbsp;Recall@5: 93% &nbsp;Recall@7: 96.33%</td>
</tr>
<tr class="even">
<td style="text-align: center;">qwen3-embedding-8B</td>
<td style="text-align: center;">Recall@3: 83.67% &nbsp;Recall@5: 93.67% &nbsp;Recall@7: 96.33%</td>
<td style="text-align: center;">Recall@3: 84.67% &nbsp;Recall@5: 93.33% &nbsp;Recall@7: 97.33%</td>
</tr>
<tr class="odd">
<td style="text-align: center;">voyage-3-large</td>
<td style="text-align: center;">Recall@3: 85% &nbsp;Recall@5: 95.33% &nbsp;Recall@7: 98.33%</td>
<td style="text-align: center;">Recall@3: 86.67% &nbsp;Recall@5: 93.67% &nbsp;Recall@7: 97.33%</td>
</tr>
</tbody>
</table>
<table class="table-striped table-hover table-bordered table">
<caption>Reranking Performance</caption>
<colgroup>
<col style="width: 30%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Embedding model</th>
<th style="text-align: center;">Without Re-ranking</th>
<th style="text-align: center;">With Re-ranking</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">voyage-3-large</td>
<td style="text-align: center;">Recall@3: 85% &nbsp;Recall@5: 95.33% &nbsp;Recall@7: 98.33%</td>
<td style="text-align: center;">Recall@3: 79.33% &nbsp;Recall@5: 88.67% &nbsp;Recall@7: 95.67%</td>
</tr>
</tbody>
</table>
</section>
<section id="retrieval" class="level5">
<h5 class="anchored" data-anchor-id="retrieval">Retrieval</h5>
<p>Based on the results of above experiments, I made the following choices for the RAG retrieval pipeline:</p>
<ul>
<li>Retrieving only top-5 relevant chunks: This is the sweet-spot between top-3 &amp; top-7 with a balance of observed performance &amp; quantity of relevant information injected into the LLM context.</li>
<li>Voyage-3-large as the embedding model: From the evaluation performances, Voyage-3-large provided the best metric for top-5 retrieved chunks.</li>
<li>Semantic search in vector-database: Again from the evaluation performances, semantic search with Voyage-3-large embedding model was better than Hybrid search.</li>
<li>No reranking after retrieval: Re-ranking post-retrieval saw a dip in Recall@5 metric performance.</li>
</ul>


</section>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>